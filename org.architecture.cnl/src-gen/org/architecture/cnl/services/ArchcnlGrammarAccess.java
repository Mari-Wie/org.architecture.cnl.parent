/*
 * generated by Xtext 2.22.0
 */
package org.architecture.cnl.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class ArchcnlGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.Model");
		private final Assignment cSentenceAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cSentenceSentenceParserRuleCall_0 = (RuleCall)cSentenceAssignment.eContents().get(0);
		
		//Model:
		//	sentence+=Sentence*;
		@Override public ParserRule getRule() { return rule; }
		
		//sentence+=Sentence*
		public Assignment getSentenceAssignment() { return cSentenceAssignment; }
		
		//Sentence
		public RuleCall getSentenceSentenceParserRuleCall_0() { return cSentenceSentenceParserRuleCall_0; }
	}
	public class SentenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.Sentence");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cEveryKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cSubjectAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cSubjectConceptExpressionParserRuleCall_0_1_0 = (RuleCall)cSubjectAssignment_0_1.eContents().get(0);
		private final Assignment cRuletypeAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final Alternatives cRuletypeAlternatives_0_2_0 = (Alternatives)cRuletypeAssignment_0_2.eContents().get(0);
		private final RuleCall cRuletypeMustRuleTypeParserRuleCall_0_2_0_0 = (RuleCall)cRuletypeAlternatives_0_2_0.eContents().get(0);
		private final RuleCall cRuletypeCanOnlyRuleTypeParserRuleCall_0_2_0_1 = (RuleCall)cRuletypeAlternatives_0_2_0.eContents().get(1);
		private final RuleCall cRuletypeCardinalityRuleTypeParserRuleCall_0_2_0_2 = (RuleCall)cRuletypeAlternatives_0_2_0.eContents().get(2);
		private final RuleCall cRuletypeSubConceptRuleTypeParserRuleCall_0_2_0_3 = (RuleCall)cRuletypeAlternatives_0_2_0.eContents().get(3);
		private final Assignment cRuletypeAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final Alternatives cRuletypeAlternatives_1_0 = (Alternatives)cRuletypeAssignment_1.eContents().get(0);
		private final RuleCall cRuletypeOnlyCanRuleTypeParserRuleCall_1_0_0 = (RuleCall)cRuletypeAlternatives_1_0.eContents().get(0);
		private final RuleCall cRuletypeConditionalRuleTypeParserRuleCall_1_0_1 = (RuleCall)cRuletypeAlternatives_1_0.eContents().get(1);
		private final RuleCall cRuletypeNegationRuleTypeParserRuleCall_1_0_2 = (RuleCall)cRuletypeAlternatives_1_0.eContents().get(2);
		private final Assignment cFactsAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cFactsFactStatementParserRuleCall_2_0 = (RuleCall)cFactsAssignment_2.eContents().get(0);
		
		//Sentence:
		//	'Every' subject=ConceptExpression ruletype=(MustRuleType | CanOnlyRuleType | CardinalityRuleType |
		//	SubConceptRuleType) | ruletype=(OnlyCanRuleType | ConditionalRuleType | NegationRuleType) | facts+=FactStatement;
		@Override public ParserRule getRule() { return rule; }
		
		//'Every' subject=ConceptExpression ruletype=(MustRuleType | CanOnlyRuleType | CardinalityRuleType | SubConceptRuleType) |
		//ruletype=(OnlyCanRuleType | ConditionalRuleType | NegationRuleType) | facts+=FactStatement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'Every' subject=ConceptExpression ruletype=(MustRuleType | CanOnlyRuleType | CardinalityRuleType | SubConceptRuleType)
		public Group getGroup_0() { return cGroup_0; }
		
		//'Every'
		public Keyword getEveryKeyword_0_0() { return cEveryKeyword_0_0; }
		
		//subject=ConceptExpression
		public Assignment getSubjectAssignment_0_1() { return cSubjectAssignment_0_1; }
		
		//ConceptExpression
		public RuleCall getSubjectConceptExpressionParserRuleCall_0_1_0() { return cSubjectConceptExpressionParserRuleCall_0_1_0; }
		
		//ruletype=(MustRuleType | CanOnlyRuleType | CardinalityRuleType | SubConceptRuleType)
		public Assignment getRuletypeAssignment_0_2() { return cRuletypeAssignment_0_2; }
		
		//(MustRuleType | CanOnlyRuleType | CardinalityRuleType | SubConceptRuleType)
		public Alternatives getRuletypeAlternatives_0_2_0() { return cRuletypeAlternatives_0_2_0; }
		
		//MustRuleType
		public RuleCall getRuletypeMustRuleTypeParserRuleCall_0_2_0_0() { return cRuletypeMustRuleTypeParserRuleCall_0_2_0_0; }
		
		//CanOnlyRuleType
		public RuleCall getRuletypeCanOnlyRuleTypeParserRuleCall_0_2_0_1() { return cRuletypeCanOnlyRuleTypeParserRuleCall_0_2_0_1; }
		
		//CardinalityRuleType
		public RuleCall getRuletypeCardinalityRuleTypeParserRuleCall_0_2_0_2() { return cRuletypeCardinalityRuleTypeParserRuleCall_0_2_0_2; }
		
		//SubConceptRuleType
		public RuleCall getRuletypeSubConceptRuleTypeParserRuleCall_0_2_0_3() { return cRuletypeSubConceptRuleTypeParserRuleCall_0_2_0_3; }
		
		//ruletype=(OnlyCanRuleType | ConditionalRuleType | NegationRuleType)
		public Assignment getRuletypeAssignment_1() { return cRuletypeAssignment_1; }
		
		//(OnlyCanRuleType | ConditionalRuleType | NegationRuleType)
		public Alternatives getRuletypeAlternatives_1_0() { return cRuletypeAlternatives_1_0; }
		
		//OnlyCanRuleType
		public RuleCall getRuletypeOnlyCanRuleTypeParserRuleCall_1_0_0() { return cRuletypeOnlyCanRuleTypeParserRuleCall_1_0_0; }
		
		//ConditionalRuleType
		public RuleCall getRuletypeConditionalRuleTypeParserRuleCall_1_0_1() { return cRuletypeConditionalRuleTypeParserRuleCall_1_0_1; }
		
		//NegationRuleType
		public RuleCall getRuletypeNegationRuleTypeParserRuleCall_1_0_2() { return cRuletypeNegationRuleTypeParserRuleCall_1_0_2; }
		
		//facts+=FactStatement
		public Assignment getFactsAssignment_2() { return cFactsAssignment_2; }
		
		//FactStatement
		public RuleCall getFactsFactStatementParserRuleCall_2_0() { return cFactsFactStatementParserRuleCall_2_0; }
	}
	public class NegationRuleTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.NegationRuleType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNothingParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Keyword cNoKeyword_1_0_0 = (Keyword)cGroup_1_0.eContents().get(0);
		private final Assignment cSubjectAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cSubjectConceptExpressionParserRuleCall_1_0_1_0 = (RuleCall)cSubjectAssignment_1_0_1.eContents().get(0);
		private final Keyword cCanKeyword_1_0_2 = (Keyword)cGroup_1_0.eContents().get(2);
		private final Assignment cObjectAssignment_1_0_3 = (Assignment)cGroup_1_0.eContents().get(3);
		private final RuleCall cObjectObjectParserRuleCall_1_0_3_0 = (RuleCall)cObjectAssignment_1_0_3.eContents().get(0);
		private final Keyword cFullStopKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		//NegationRuleType:
		//	Nothing | ('No' subject=ConceptExpression 'can' object=Object) '.';
		@Override public ParserRule getRule() { return rule; }
		
		//Nothing | ('No' subject=ConceptExpression 'can' object=Object) '.'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Nothing
		public RuleCall getNothingParserRuleCall_0() { return cNothingParserRuleCall_0; }
		
		//('No' subject=ConceptExpression 'can' object=Object) '.'
		public Group getGroup_1() { return cGroup_1; }
		
		//('No' subject=ConceptExpression 'can' object=Object)
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//'No'
		public Keyword getNoKeyword_1_0_0() { return cNoKeyword_1_0_0; }
		
		//subject=ConceptExpression
		public Assignment getSubjectAssignment_1_0_1() { return cSubjectAssignment_1_0_1; }
		
		//ConceptExpression
		public RuleCall getSubjectConceptExpressionParserRuleCall_1_0_1_0() { return cSubjectConceptExpressionParserRuleCall_1_0_1_0; }
		
		//'can'
		public Keyword getCanKeyword_1_0_2() { return cCanKeyword_1_0_2; }
		
		//object=Object
		public Assignment getObjectAssignment_1_0_3() { return cObjectAssignment_1_0_3; }
		
		//Object
		public RuleCall getObjectObjectParserRuleCall_1_0_3_0() { return cObjectObjectParserRuleCall_1_0_3_0; }
		
		//'.'
		public Keyword getFullStopKeyword_1_1() { return cFullStopKeyword_1_1; }
	}
	public class AnythingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.Anything");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cRelationAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cRelationRelationParserRuleCall_0_0 = (RuleCall)cRelationAssignment_0.eContents().get(0);
		private final Keyword cAnythingKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Anything:
		//	relation=Relation 'anything';
		@Override public ParserRule getRule() { return rule; }
		
		//relation=Relation 'anything'
		public Group getGroup() { return cGroup; }
		
		//relation=Relation
		public Assignment getRelationAssignment_0() { return cRelationAssignment_0; }
		
		//Relation
		public RuleCall getRelationRelationParserRuleCall_0_0() { return cRelationRelationParserRuleCall_0_0; }
		
		//'anything'
		public Keyword getAnythingKeyword_1() { return cAnythingKeyword_1; }
	}
	public class NothingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.Nothing");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNothingKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cCanKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cObjectAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cObjectObjectParserRuleCall_2_0 = (RuleCall)cObjectAssignment_2.eContents().get(0);
		private final Keyword cFullStopKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Nothing:
		//	'Nothing' 'can' object=Object '.';
		@Override public ParserRule getRule() { return rule; }
		
		//'Nothing' 'can' object=Object '.'
		public Group getGroup() { return cGroup; }
		
		//'Nothing'
		public Keyword getNothingKeyword_0() { return cNothingKeyword_0; }
		
		//'can'
		public Keyword getCanKeyword_1() { return cCanKeyword_1; }
		
		//object=Object
		public Assignment getObjectAssignment_2() { return cObjectAssignment_2; }
		
		//Object
		public RuleCall getObjectObjectParserRuleCall_2_0() { return cObjectObjectParserRuleCall_2_0; }
		
		//'.'
		public Keyword getFullStopKeyword_3() { return cFullStopKeyword_3; }
	}
	public class ConditionalRuleTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.ConditionalRuleType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStartAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cStartIfKeyword_0_0 = (Keyword)cStartAssignment_0.eContents().get(0);
		private final Assignment cSubjectAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSubjectConceptExpressionParserRuleCall_1_0 = (RuleCall)cSubjectAssignment_1.eContents().get(0);
		private final Assignment cRelationAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRelationRelationParserRuleCall_2_0 = (RuleCall)cRelationAssignment_2.eContents().get(0);
		private final Assignment cObjectAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cObjectConceptExpressionParserRuleCall_3_0 = (RuleCall)cObjectAssignment_3.eContents().get(0);
		private final Keyword cCommaKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cThenKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cItKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cMustKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cRelation2Assignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cRelation2RelationParserRuleCall_8_0 = (RuleCall)cRelation2Assignment_8.eContents().get(0);
		private final Keyword cThisKeyword_9 = (Keyword)cGroup.eContents().get(9);
		private final Assignment cObject2Assignment_10 = (Assignment)cGroup.eContents().get(10);
		private final RuleCall cObject2ConceptExpressionParserRuleCall_10_0 = (RuleCall)cObject2Assignment_10.eContents().get(0);
		private final Keyword cFullStopKeyword_11 = (Keyword)cGroup.eContents().get(11);
		
		//ConditionalRuleType:
		//	start='If' subject=ConceptExpression relation=Relation object=ConceptExpression ',' 'then' 'it' 'must'
		//	relation2=Relation 'this' object2=ConceptExpression '.';
		@Override public ParserRule getRule() { return rule; }
		
		//start='If' subject=ConceptExpression relation=Relation object=ConceptExpression ',' 'then' 'it' 'must'
		//relation2=Relation 'this' object2=ConceptExpression '.'
		public Group getGroup() { return cGroup; }
		
		//start='If'
		public Assignment getStartAssignment_0() { return cStartAssignment_0; }
		
		//'If'
		public Keyword getStartIfKeyword_0_0() { return cStartIfKeyword_0_0; }
		
		//subject=ConceptExpression
		public Assignment getSubjectAssignment_1() { return cSubjectAssignment_1; }
		
		//ConceptExpression
		public RuleCall getSubjectConceptExpressionParserRuleCall_1_0() { return cSubjectConceptExpressionParserRuleCall_1_0; }
		
		//relation=Relation
		public Assignment getRelationAssignment_2() { return cRelationAssignment_2; }
		
		//Relation
		public RuleCall getRelationRelationParserRuleCall_2_0() { return cRelationRelationParserRuleCall_2_0; }
		
		//object=ConceptExpression
		public Assignment getObjectAssignment_3() { return cObjectAssignment_3; }
		
		//ConceptExpression
		public RuleCall getObjectConceptExpressionParserRuleCall_3_0() { return cObjectConceptExpressionParserRuleCall_3_0; }
		
		//','
		public Keyword getCommaKeyword_4() { return cCommaKeyword_4; }
		
		//'then'
		public Keyword getThenKeyword_5() { return cThenKeyword_5; }
		
		//'it'
		public Keyword getItKeyword_6() { return cItKeyword_6; }
		
		//'must'
		public Keyword getMustKeyword_7() { return cMustKeyword_7; }
		
		//relation2=Relation
		public Assignment getRelation2Assignment_8() { return cRelation2Assignment_8; }
		
		//Relation
		public RuleCall getRelation2RelationParserRuleCall_8_0() { return cRelation2RelationParserRuleCall_8_0; }
		
		//'this'
		public Keyword getThisKeyword_9() { return cThisKeyword_9; }
		
		//object2=ConceptExpression
		public Assignment getObject2Assignment_10() { return cObject2Assignment_10; }
		
		//ConceptExpression
		public RuleCall getObject2ConceptExpressionParserRuleCall_10_0() { return cObject2ConceptExpressionParserRuleCall_10_0; }
		
		//'.'
		public Keyword getFullStopKeyword_11() { return cFullStopKeyword_11; }
	}
	public class OnlyCanRuleTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.OnlyCanRuleType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStartAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cStartOnlyKeyword_0_0 = (Keyword)cStartAssignment_0.eContents().get(0);
		private final Assignment cSubjectAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSubjectConceptExpressionParserRuleCall_1_0 = (RuleCall)cSubjectAssignment_1.eContents().get(0);
		private final Keyword cCanKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cObjectAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cObjectObjectParserRuleCall_3_0 = (RuleCall)cObjectAssignment_3.eContents().get(0);
		private final Keyword cFullStopKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//OnlyCanRuleType:
		//	start='Only' subject=ConceptExpression 'can' object=Object '.';
		@Override public ParserRule getRule() { return rule; }
		
		//start='Only' subject=ConceptExpression 'can' object=Object '.'
		public Group getGroup() { return cGroup; }
		
		//start='Only'
		public Assignment getStartAssignment_0() { return cStartAssignment_0; }
		
		//'Only'
		public Keyword getStartOnlyKeyword_0_0() { return cStartOnlyKeyword_0_0; }
		
		//subject=ConceptExpression
		public Assignment getSubjectAssignment_1() { return cSubjectAssignment_1; }
		
		//ConceptExpression
		public RuleCall getSubjectConceptExpressionParserRuleCall_1_0() { return cSubjectConceptExpressionParserRuleCall_1_0; }
		
		//'can'
		public Keyword getCanKeyword_2() { return cCanKeyword_2; }
		
		//object=Object
		public Assignment getObjectAssignment_3() { return cObjectAssignment_3; }
		
		//Object
		public RuleCall getObjectObjectParserRuleCall_3_0() { return cObjectObjectParserRuleCall_3_0; }
		
		//'.'
		public Keyword getFullStopKeyword_4() { return cFullStopKeyword_4; }
	}
	public class SubConceptRuleTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.SubConceptRuleType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cModifierAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cModifierMustKeyword_0_0 = (Keyword)cModifierAssignment_0.eContents().get(0);
		private final Keyword cBeKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cObjectAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cObjectConceptExpressionParserRuleCall_2_0 = (RuleCall)cObjectAssignment_2.eContents().get(0);
		private final Keyword cFullStopKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//SubConceptRuleType:
		//	modifier='must' 'be' object=ConceptExpression '.';
		@Override public ParserRule getRule() { return rule; }
		
		//modifier='must' 'be' object=ConceptExpression '.'
		public Group getGroup() { return cGroup; }
		
		//modifier='must'
		public Assignment getModifierAssignment_0() { return cModifierAssignment_0; }
		
		//'must'
		public Keyword getModifierMustKeyword_0_0() { return cModifierMustKeyword_0_0; }
		
		//'be'
		public Keyword getBeKeyword_1() { return cBeKeyword_1; }
		
		//object=ConceptExpression
		public Assignment getObjectAssignment_2() { return cObjectAssignment_2; }
		
		//ConceptExpression
		public RuleCall getObjectConceptExpressionParserRuleCall_2_0() { return cObjectConceptExpressionParserRuleCall_2_0; }
		
		//'.'
		public Keyword getFullStopKeyword_3() { return cFullStopKeyword_3; }
	}
	public class MustRuleTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.MustRuleType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cModifierAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cModifierMustKeyword_0_0 = (Keyword)cModifierAssignment_0.eContents().get(0);
		private final Assignment cObjectAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cObjectObjectParserRuleCall_1_0 = (RuleCall)cObjectAssignment_1.eContents().get(0);
		private final Keyword cFullStopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//MustRuleType:
		//	modifier='must' object=Object '.';
		@Override public ParserRule getRule() { return rule; }
		
		//modifier='must' object=Object '.'
		public Group getGroup() { return cGroup; }
		
		//modifier='must'
		public Assignment getModifierAssignment_0() { return cModifierAssignment_0; }
		
		//'must'
		public Keyword getModifierMustKeyword_0_0() { return cModifierMustKeyword_0_0; }
		
		//object=Object
		public Assignment getObjectAssignment_1() { return cObjectAssignment_1; }
		
		//Object
		public RuleCall getObjectObjectParserRuleCall_1_0() { return cObjectObjectParserRuleCall_1_0; }
		
		//'.'
		public Keyword getFullStopKeyword_2() { return cFullStopKeyword_2; }
	}
	public class ObjectElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.Object");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cAnythingAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cAnythingAnythingParserRuleCall_0_0 = (RuleCall)cAnythingAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cExpressionAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cExpressionObjectConceptExpressionParserRuleCall_1_0_0 = (RuleCall)cExpressionAssignment_1_0.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Assignment cObjectAndListAssignment_1_1_0 = (Assignment)cAlternatives_1_1.eContents().get(0);
		private final RuleCall cObjectAndListAndObjectConceptExpressionParserRuleCall_1_1_0_0 = (RuleCall)cObjectAndListAssignment_1_1_0.eContents().get(0);
		private final Assignment cObjectOrListAssignment_1_1_1 = (Assignment)cAlternatives_1_1.eContents().get(1);
		private final RuleCall cObjectOrListOrObjectConceptExpressionParserRuleCall_1_1_1_0 = (RuleCall)cObjectOrListAssignment_1_1_1.eContents().get(0);
		
		//Object:
		//	anything=Anything | expression=ObjectConceptExpression (objectAndList+=AndObjectConceptExpression |
		//	objectOrList+=OrObjectConceptExpression)*;
		@Override public ParserRule getRule() { return rule; }
		
		//anything=Anything | expression=ObjectConceptExpression (objectAndList+=AndObjectConceptExpression |
		//objectOrList+=OrObjectConceptExpression)*
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//anything=Anything
		public Assignment getAnythingAssignment_0() { return cAnythingAssignment_0; }
		
		//Anything
		public RuleCall getAnythingAnythingParserRuleCall_0_0() { return cAnythingAnythingParserRuleCall_0_0; }
		
		//expression=ObjectConceptExpression (objectAndList+=AndObjectConceptExpression |
		//objectOrList+=OrObjectConceptExpression)*
		public Group getGroup_1() { return cGroup_1; }
		
		//expression=ObjectConceptExpression
		public Assignment getExpressionAssignment_1_0() { return cExpressionAssignment_1_0; }
		
		//ObjectConceptExpression
		public RuleCall getExpressionObjectConceptExpressionParserRuleCall_1_0_0() { return cExpressionObjectConceptExpressionParserRuleCall_1_0_0; }
		
		//(objectAndList+=AndObjectConceptExpression | objectOrList+=OrObjectConceptExpression)*
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }
		
		//objectAndList+=AndObjectConceptExpression
		public Assignment getObjectAndListAssignment_1_1_0() { return cObjectAndListAssignment_1_1_0; }
		
		//AndObjectConceptExpression
		public RuleCall getObjectAndListAndObjectConceptExpressionParserRuleCall_1_1_0_0() { return cObjectAndListAndObjectConceptExpressionParserRuleCall_1_1_0_0; }
		
		//objectOrList+=OrObjectConceptExpression
		public Assignment getObjectOrListAssignment_1_1_1() { return cObjectOrListAssignment_1_1_1; }
		
		//OrObjectConceptExpression
		public RuleCall getObjectOrListOrObjectConceptExpressionParserRuleCall_1_1_1_0() { return cObjectOrListOrObjectConceptExpressionParserRuleCall_1_1_1_0; }
	}
	public class CanOnlyRuleTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.CanOnlyRuleType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cModifierAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cModifierCanOnlyKeyword_0_0 = (Keyword)cModifierAssignment_0.eContents().get(0);
		private final Assignment cObjectAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cObjectObjectParserRuleCall_1_0 = (RuleCall)cObjectAssignment_1.eContents().get(0);
		private final Keyword cFullStopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//CanOnlyRuleType:
		//	modifier='can-only' object=Object '.';
		@Override public ParserRule getRule() { return rule; }
		
		//modifier='can-only' object=Object '.'
		public Group getGroup() { return cGroup; }
		
		//modifier='can-only'
		public Assignment getModifierAssignment_0() { return cModifierAssignment_0; }
		
		//'can-only'
		public Keyword getModifierCanOnlyKeyword_0_0() { return cModifierCanOnlyKeyword_0_0; }
		
		//object=Object
		public Assignment getObjectAssignment_1() { return cObjectAssignment_1; }
		
		//Object
		public RuleCall getObjectObjectParserRuleCall_1_0() { return cObjectObjectParserRuleCall_1_0; }
		
		//'.'
		public Keyword getFullStopKeyword_2() { return cFullStopKeyword_2; }
	}
	public class CardinalityRuleTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.CardinalityRuleType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cModiferAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cModiferCanKeyword_0_0 = (Keyword)cModiferAssignment_0.eContents().get(0);
		private final Assignment cObjectAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cObjectObjectParserRuleCall_1_0 = (RuleCall)cObjectAssignment_1.eContents().get(0);
		private final Keyword cFullStopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		////TODO: must anstatt can. Problem: Konflikt mit MustRuleType
		//CardinalityRuleType:
		//	modifer='can' object=Object '.';
		@Override public ParserRule getRule() { return rule; }
		
		//modifer='can' object=Object '.'
		public Group getGroup() { return cGroup; }
		
		//modifer='can'
		public Assignment getModiferAssignment_0() { return cModiferAssignment_0; }
		
		//'can'
		public Keyword getModiferCanKeyword_0_0() { return cModiferCanKeyword_0_0; }
		
		//object=Object
		public Assignment getObjectAssignment_1() { return cObjectAssignment_1; }
		
		//Object
		public RuleCall getObjectObjectParserRuleCall_1_0() { return cObjectObjectParserRuleCall_1_0; }
		
		//'.'
		public Keyword getFullStopKeyword_2() { return cFullStopKeyword_2; }
	}
	public class ObjectConceptExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.ObjectConceptExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cRelationAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cRelationRelationParserRuleCall_0_0_0 = (RuleCall)cRelationAssignment_0_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cGroup_0.eContents().get(1);
		private final Assignment cCardinalityAssignment_0_1_0 = (Assignment)cGroup_0_1.eContents().get(0);
		private final Alternatives cCardinalityAlternatives_0_1_0_0 = (Alternatives)cCardinalityAssignment_0_1_0.eContents().get(0);
		private final Keyword cCardinalityAtMostKeyword_0_1_0_0_0 = (Keyword)cCardinalityAlternatives_0_1_0_0.eContents().get(0);
		private final Keyword cCardinalityAtLeastKeyword_0_1_0_0_1 = (Keyword)cCardinalityAlternatives_0_1_0_0.eContents().get(1);
		private final Keyword cCardinalityExactlyKeyword_0_1_0_0_2 = (Keyword)cCardinalityAlternatives_0_1_0_0.eContents().get(2);
		private final Assignment cNumberAssignment_0_1_1 = (Assignment)cGroup_0_1.eContents().get(1);
		private final RuleCall cNumberINTTerminalRuleCall_0_1_1_0 = (RuleCall)cNumberAssignment_0_1_1.eContents().get(0);
		private final Assignment cConceptAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cConceptConceptExpressionParserRuleCall_0_2_0 = (RuleCall)cConceptAssignment_0_2.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cRelationAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cRelationDatatypeRelationParserRuleCall_1_0_0 = (RuleCall)cRelationAssignment_1_0.eContents().get(0);
		private final Assignment cDataAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cDataDataStatementParserRuleCall_1_1_0 = (RuleCall)cDataAssignment_1_1.eContents().get(0);
		
		//ObjectConceptExpression:
		//	relation=Relation (cardinality=('at-most' | 'at-least' | 'exactly') number=INT)? concept=ConceptExpression |
		//	relation=DatatypeRelation data=DataStatement;
		@Override public ParserRule getRule() { return rule; }
		
		//relation=Relation (cardinality=('at-most' | 'at-least' | 'exactly') number=INT)? concept=ConceptExpression |
		//relation=DatatypeRelation data=DataStatement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//relation=Relation (cardinality=('at-most' | 'at-least' | 'exactly') number=INT)? concept=ConceptExpression
		public Group getGroup_0() { return cGroup_0; }
		
		//relation=Relation
		public Assignment getRelationAssignment_0_0() { return cRelationAssignment_0_0; }
		
		//Relation
		public RuleCall getRelationRelationParserRuleCall_0_0_0() { return cRelationRelationParserRuleCall_0_0_0; }
		
		//(cardinality=('at-most' | 'at-least' | 'exactly') number=INT)?
		public Group getGroup_0_1() { return cGroup_0_1; }
		
		//cardinality=('at-most' | 'at-least' | 'exactly')
		public Assignment getCardinalityAssignment_0_1_0() { return cCardinalityAssignment_0_1_0; }
		
		//('at-most' | 'at-least' | 'exactly')
		public Alternatives getCardinalityAlternatives_0_1_0_0() { return cCardinalityAlternatives_0_1_0_0; }
		
		//'at-most'
		public Keyword getCardinalityAtMostKeyword_0_1_0_0_0() { return cCardinalityAtMostKeyword_0_1_0_0_0; }
		
		//'at-least'
		public Keyword getCardinalityAtLeastKeyword_0_1_0_0_1() { return cCardinalityAtLeastKeyword_0_1_0_0_1; }
		
		//'exactly'
		public Keyword getCardinalityExactlyKeyword_0_1_0_0_2() { return cCardinalityExactlyKeyword_0_1_0_0_2; }
		
		//number=INT
		public Assignment getNumberAssignment_0_1_1() { return cNumberAssignment_0_1_1; }
		
		//INT
		public RuleCall getNumberINTTerminalRuleCall_0_1_1_0() { return cNumberINTTerminalRuleCall_0_1_1_0; }
		
		//concept=ConceptExpression
		public Assignment getConceptAssignment_0_2() { return cConceptAssignment_0_2; }
		
		//ConceptExpression
		public RuleCall getConceptConceptExpressionParserRuleCall_0_2_0() { return cConceptConceptExpressionParserRuleCall_0_2_0; }
		
		//relation=DatatypeRelation data=DataStatement
		public Group getGroup_1() { return cGroup_1; }
		
		//relation=DatatypeRelation
		public Assignment getRelationAssignment_1_0() { return cRelationAssignment_1_0; }
		
		//DatatypeRelation
		public RuleCall getRelationDatatypeRelationParserRuleCall_1_0_0() { return cRelationDatatypeRelationParserRuleCall_1_0_0; }
		
		//data=DataStatement
		public Assignment getDataAssignment_1_1() { return cDataAssignment_1_1; }
		
		//DataStatement
		public RuleCall getDataDataStatementParserRuleCall_1_1_0() { return cDataDataStatementParserRuleCall_1_1_0; }
	}
	public class AndObjectConceptExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.AndObjectConceptExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAndKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionObjectConceptExpressionParserRuleCall_1_0 = (RuleCall)cExpressionAssignment_1.eContents().get(0);
		
		//AndObjectConceptExpression:
		//	'and' expression=ObjectConceptExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//'and' expression=ObjectConceptExpression
		public Group getGroup() { return cGroup; }
		
		//'and'
		public Keyword getAndKeyword_0() { return cAndKeyword_0; }
		
		//expression=ObjectConceptExpression
		public Assignment getExpressionAssignment_1() { return cExpressionAssignment_1; }
		
		//ObjectConceptExpression
		public RuleCall getExpressionObjectConceptExpressionParserRuleCall_1_0() { return cExpressionObjectConceptExpressionParserRuleCall_1_0; }
	}
	public class OrObjectConceptExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.OrObjectConceptExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cOrKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionObjectConceptExpressionParserRuleCall_1_0 = (RuleCall)cExpressionAssignment_1.eContents().get(0);
		
		//OrObjectConceptExpression:
		//	'or' expression=ObjectConceptExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//'or' expression=ObjectConceptExpression
		public Group getGroup() { return cGroup; }
		
		//'or'
		public Keyword getOrKeyword_0() { return cOrKeyword_0; }
		
		//expression=ObjectConceptExpression
		public Assignment getExpressionAssignment_1() { return cExpressionAssignment_1; }
		
		//ObjectConceptExpression
		public RuleCall getExpressionObjectConceptExpressionParserRuleCall_1_0() { return cExpressionObjectConceptExpressionParserRuleCall_1_0; }
	}
	public class RelationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.Relation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cObjectRelationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDatatypeRelationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Relation:
		//	ObjectRelation | DatatypeRelation;
		@Override public ParserRule getRule() { return rule; }
		
		//ObjectRelation | DatatypeRelation
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ObjectRelation
		public RuleCall getObjectRelationParserRuleCall_0() { return cObjectRelationParserRuleCall_0; }
		
		//DatatypeRelation
		public RuleCall getDatatypeRelationParserRuleCall_1() { return cDatatypeRelationParserRuleCall_1; }
	}
	public class DatatypeRelationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.DatatypeRelation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cRelationNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cRelationNameRELATION_NAMETerminalRuleCall_0_0 = (RuleCall)cRelationNameAssignment_0.eContents().get(0);
		private final Keyword cEqualToKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//DatatypeRelation:
		//	relationName=RELATION_NAME 'equal-to';
		@Override public ParserRule getRule() { return rule; }
		
		//relationName=RELATION_NAME 'equal-to'
		public Group getGroup() { return cGroup; }
		
		//relationName=RELATION_NAME
		public Assignment getRelationNameAssignment_0() { return cRelationNameAssignment_0; }
		
		//RELATION_NAME
		public RuleCall getRelationNameRELATION_NAMETerminalRuleCall_0_0() { return cRelationNameRELATION_NAMETerminalRuleCall_0_0; }
		
		//'equal-to'
		public Keyword getEqualToKeyword_1() { return cEqualToKeyword_1; }
	}
	public class ObjectRelationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.ObjectRelation");
		private final Assignment cRelationNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cRelationNameRELATION_NAMETerminalRuleCall_0 = (RuleCall)cRelationNameAssignment.eContents().get(0);
		
		//ObjectRelation:
		//	relationName=RELATION_NAME;
		@Override public ParserRule getRule() { return rule; }
		
		//relationName=RELATION_NAME
		public Assignment getRelationNameAssignment() { return cRelationNameAssignment; }
		
		//RELATION_NAME
		public RuleCall getRelationNameRELATION_NAMETerminalRuleCall_0() { return cRelationNameRELATION_NAMETerminalRuleCall_0; }
	}
	public class ConceptExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.ConceptExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cAKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cAnKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Assignment cConceptAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConceptConceptParserRuleCall_1_0 = (RuleCall)cConceptAssignment_1.eContents().get(0);
		private final Assignment cThatAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cThatThatExpressionParserRuleCall_2_0 = (RuleCall)cThatAssignment_2.eContents().get(0);
		
		//ConceptExpression:
		//	('a' | 'an')? concept=Concept that+=ThatExpression*;
		@Override public ParserRule getRule() { return rule; }
		
		//('a' | 'an')? concept=Concept that+=ThatExpression*
		public Group getGroup() { return cGroup; }
		
		//('a' | 'an')?
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//'a'
		public Keyword getAKeyword_0_0() { return cAKeyword_0_0; }
		
		//'an'
		public Keyword getAnKeyword_0_1() { return cAnKeyword_0_1; }
		
		//concept=Concept
		public Assignment getConceptAssignment_1() { return cConceptAssignment_1; }
		
		//Concept
		public RuleCall getConceptConceptParserRuleCall_1_0() { return cConceptConceptParserRuleCall_1_0; }
		
		//that+=ThatExpression*
		public Assignment getThatAssignment_2() { return cThatAssignment_2; }
		
		//ThatExpression
		public RuleCall getThatThatExpressionParserRuleCall_2_0() { return cThatThatExpressionParserRuleCall_2_0; }
	}
	public class ThatExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.ThatExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cThatKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cListAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cListStatementListParserRuleCall_2_0 = (RuleCall)cListAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ThatExpression:
		//	'that' '(' list+=StatementList+ ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'that' '(' list+=StatementList+ ')'
		public Group getGroup() { return cGroup; }
		
		//'that'
		public Keyword getThatKeyword_0() { return cThatKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//list+=StatementList+
		public Assignment getListAssignment_2() { return cListAssignment_2; }
		
		//StatementList
		public RuleCall getListStatementListParserRuleCall_2_0() { return cListStatementListParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class StatementListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.StatementList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAndKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cRelationAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cRelationRelationParserRuleCall_1_0_0 = (RuleCall)cRelationAssignment_1_0.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Assignment cExpressionAssignment_1_1_0 = (Assignment)cAlternatives_1_1.eContents().get(0);
		private final RuleCall cExpressionConceptExpressionParserRuleCall_1_1_0_0 = (RuleCall)cExpressionAssignment_1_1_0.eContents().get(0);
		private final Assignment cExpressionAssignment_1_1_1 = (Assignment)cAlternatives_1_1.eContents().get(1);
		private final RuleCall cExpressionDataStatementParserRuleCall_1_1_1_0 = (RuleCall)cExpressionAssignment_1_1_1.eContents().get(0);
		private final Assignment cExpressionAssignment_1_1_2 = (Assignment)cAlternatives_1_1.eContents().get(2);
		private final RuleCall cExpressionVariableStatementParserRuleCall_1_1_2_0 = (RuleCall)cExpressionAssignment_1_1_2.eContents().get(0);
		
		//StatementList:
		//	'and'? (relation=Relation (expression=ConceptExpression | expression=DataStatement | expression=VariableStatement));
		@Override public ParserRule getRule() { return rule; }
		
		//'and'? (relation=Relation (expression=ConceptExpression | expression=DataStatement | expression=VariableStatement))
		public Group getGroup() { return cGroup; }
		
		//'and'?
		public Keyword getAndKeyword_0() { return cAndKeyword_0; }
		
		//(relation=Relation (expression=ConceptExpression | expression=DataStatement | expression=VariableStatement))
		public Group getGroup_1() { return cGroup_1; }
		
		//relation=Relation
		public Assignment getRelationAssignment_1_0() { return cRelationAssignment_1_0; }
		
		//Relation
		public RuleCall getRelationRelationParserRuleCall_1_0_0() { return cRelationRelationParserRuleCall_1_0_0; }
		
		//(expression=ConceptExpression | expression=DataStatement | expression=VariableStatement)
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }
		
		//expression=ConceptExpression
		public Assignment getExpressionAssignment_1_1_0() { return cExpressionAssignment_1_1_0; }
		
		//ConceptExpression
		public RuleCall getExpressionConceptExpressionParserRuleCall_1_1_0_0() { return cExpressionConceptExpressionParserRuleCall_1_1_0_0; }
		
		//expression=DataStatement
		public Assignment getExpressionAssignment_1_1_1() { return cExpressionAssignment_1_1_1; }
		
		//DataStatement
		public RuleCall getExpressionDataStatementParserRuleCall_1_1_1_0() { return cExpressionDataStatementParserRuleCall_1_1_1_0; }
		
		//expression=VariableStatement
		public Assignment getExpressionAssignment_1_1_2() { return cExpressionAssignment_1_1_2; }
		
		//VariableStatement
		public RuleCall getExpressionVariableStatementParserRuleCall_1_1_2_0() { return cExpressionVariableStatementParserRuleCall_1_1_2_0; }
	}
	public class VariableStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.VariableStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cConceptAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cConceptConceptParserRuleCall_0_0 = (RuleCall)cConceptAssignment_0.eContents().get(0);
		private final Assignment cVariableAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVariableVariableParserRuleCall_1_0 = (RuleCall)cVariableAssignment_1.eContents().get(0);
		
		//VariableStatement:
		//	concept=Concept variable=Variable;
		@Override public ParserRule getRule() { return rule; }
		
		//concept=Concept variable=Variable
		public Group getGroup() { return cGroup; }
		
		//concept=Concept
		public Assignment getConceptAssignment_0() { return cConceptAssignment_0; }
		
		//Concept
		public RuleCall getConceptConceptParserRuleCall_0_0() { return cConceptConceptParserRuleCall_0_0; }
		
		//variable=Variable
		public Assignment getVariableAssignment_1() { return cVariableAssignment_1; }
		
		//Variable
		public RuleCall getVariableVariableParserRuleCall_1_0() { return cVariableVariableParserRuleCall_1_0; }
	}
	public class DataStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.DataStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cStringValueAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cStringValueSTRINGTerminalRuleCall_0_0 = (RuleCall)cStringValueAssignment_0.eContents().get(0);
		private final Assignment cIntValueAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cIntValueINTTerminalRuleCall_1_0 = (RuleCall)cIntValueAssignment_1.eContents().get(0);
		
		//DataStatement:
		//	stringValue=STRING | intValue=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//stringValue=STRING | intValue=INT
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//stringValue=STRING
		public Assignment getStringValueAssignment_0() { return cStringValueAssignment_0; }
		
		//STRING
		public RuleCall getStringValueSTRINGTerminalRuleCall_0_0() { return cStringValueSTRINGTerminalRuleCall_0_0; }
		
		//intValue=INT
		public Assignment getIntValueAssignment_1() { return cIntValueAssignment_1; }
		
		//INT
		public RuleCall getIntValueINTTerminalRuleCall_1_0() { return cIntValueINTTerminalRuleCall_1_0; }
	}
	public class FactStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.FactStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cAssertionAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final RuleCall cAssertionConceptAssertionParserRuleCall_0_0_0 = (RuleCall)cAssertionAssignment_0_0.eContents().get(0);
		private final Assignment cAssertionAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final RuleCall cAssertionRoleAssertionParserRuleCall_0_1_0 = (RuleCall)cAssertionAssignment_0_1.eContents().get(0);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//FactStatement:
		//	(assertion=ConceptAssertion | assertion=RoleAssertion) '.';
		@Override public ParserRule getRule() { return rule; }
		
		//(assertion=ConceptAssertion | assertion=RoleAssertion) '.'
		public Group getGroup() { return cGroup; }
		
		//(assertion=ConceptAssertion | assertion=RoleAssertion)
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//assertion=ConceptAssertion
		public Assignment getAssertionAssignment_0_0() { return cAssertionAssignment_0_0; }
		
		//ConceptAssertion
		public RuleCall getAssertionConceptAssertionParserRuleCall_0_0_0() { return cAssertionConceptAssertionParserRuleCall_0_0_0; }
		
		//assertion=RoleAssertion
		public Assignment getAssertionAssignment_0_1() { return cAssertionAssignment_0_1; }
		
		//RoleAssertion
		public RuleCall getAssertionRoleAssertionParserRuleCall_0_1_0() { return cAssertionRoleAssertionParserRuleCall_0_1_0; }
		
		//'.'
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }
	}
	public class ConceptAssertionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.ConceptAssertion");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIndividualAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cIndividualNAMETerminalRuleCall_0_0 = (RuleCall)cIndividualAssignment_0.eContents().get(0);
		private final Keyword cIsKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Keyword cAKeyword_2_0 = (Keyword)cAlternatives_2.eContents().get(0);
		private final Keyword cAnKeyword_2_1 = (Keyword)cAlternatives_2.eContents().get(1);
		private final Assignment cConceptAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cConceptConceptParserRuleCall_3_0 = (RuleCall)cConceptAssignment_3.eContents().get(0);
		private final Keyword cFullStopKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//ConceptAssertion:
		//	individual=NAME 'is' ('a' | 'an') concept=Concept '.';
		@Override public ParserRule getRule() { return rule; }
		
		//individual=NAME 'is' ('a' | 'an') concept=Concept '.'
		public Group getGroup() { return cGroup; }
		
		//individual=NAME
		public Assignment getIndividualAssignment_0() { return cIndividualAssignment_0; }
		
		//NAME
		public RuleCall getIndividualNAMETerminalRuleCall_0_0() { return cIndividualNAMETerminalRuleCall_0_0; }
		
		//'is'
		public Keyword getIsKeyword_1() { return cIsKeyword_1; }
		
		//('a' | 'an')
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//'a'
		public Keyword getAKeyword_2_0() { return cAKeyword_2_0; }
		
		//'an'
		public Keyword getAnKeyword_2_1() { return cAnKeyword_2_1; }
		
		//concept=Concept
		public Assignment getConceptAssignment_3() { return cConceptAssignment_3; }
		
		//Concept
		public RuleCall getConceptConceptParserRuleCall_3_0() { return cConceptConceptParserRuleCall_3_0; }
		
		//'.'
		public Keyword getFullStopKeyword_4() { return cFullStopKeyword_4; }
	}
	public class RoleAssertionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.RoleAssertion");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cObjectPropertyAssertionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cDatatypePropertyAssertionParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Keyword cFullStopKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		//RoleAssertion:
		//	ObjectPropertyAssertion | DatatypePropertyAssertion '.';
		@Override public ParserRule getRule() { return rule; }
		
		//ObjectPropertyAssertion | DatatypePropertyAssertion '.'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ObjectPropertyAssertion
		public RuleCall getObjectPropertyAssertionParserRuleCall_0() { return cObjectPropertyAssertionParserRuleCall_0; }
		
		//DatatypePropertyAssertion '.'
		public Group getGroup_1() { return cGroup_1; }
		
		//DatatypePropertyAssertion
		public RuleCall getDatatypePropertyAssertionParserRuleCall_1_0() { return cDatatypePropertyAssertionParserRuleCall_1_0; }
		
		//'.'
		public Keyword getFullStopKeyword_1_1() { return cFullStopKeyword_1_1; }
	}
	public class DatatypePropertyAssertionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.DatatypePropertyAssertion");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIndividualAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cIndividualNAMETerminalRuleCall_0_0 = (RuleCall)cIndividualAssignment_0.eContents().get(0);
		private final Assignment cRelationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRelationDatatypeRelationParserRuleCall_1_0 = (RuleCall)cRelationAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cStringAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cStringSTRINGTerminalRuleCall_2_0_0 = (RuleCall)cStringAssignment_2_0.eContents().get(0);
		private final Assignment cIntAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cIntINTTerminalRuleCall_2_1_0 = (RuleCall)cIntAssignment_2_1.eContents().get(0);
		
		//DatatypePropertyAssertion:
		//	individual=NAME relation=DatatypeRelation (string=STRING | int=INT);
		@Override public ParserRule getRule() { return rule; }
		
		//individual=NAME relation=DatatypeRelation (string=STRING | int=INT)
		public Group getGroup() { return cGroup; }
		
		//individual=NAME
		public Assignment getIndividualAssignment_0() { return cIndividualAssignment_0; }
		
		//NAME
		public RuleCall getIndividualNAMETerminalRuleCall_0_0() { return cIndividualNAMETerminalRuleCall_0_0; }
		
		//relation=DatatypeRelation
		public Assignment getRelationAssignment_1() { return cRelationAssignment_1; }
		
		//DatatypeRelation
		public RuleCall getRelationDatatypeRelationParserRuleCall_1_0() { return cRelationDatatypeRelationParserRuleCall_1_0; }
		
		//(string=STRING | int=INT)
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//string=STRING
		public Assignment getStringAssignment_2_0() { return cStringAssignment_2_0; }
		
		//STRING
		public RuleCall getStringSTRINGTerminalRuleCall_2_0_0() { return cStringSTRINGTerminalRuleCall_2_0_0; }
		
		//int=INT
		public Assignment getIntAssignment_2_1() { return cIntAssignment_2_1; }
		
		//INT
		public RuleCall getIntINTTerminalRuleCall_2_1_0() { return cIntINTTerminalRuleCall_2_1_0; }
	}
	public class ObjectPropertyAssertionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.ObjectPropertyAssertion");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIndividualAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cIndividualNAMETerminalRuleCall_0_0 = (RuleCall)cIndividualAssignment_0.eContents().get(0);
		private final Assignment cRelationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRelationRelationParserRuleCall_1_0 = (RuleCall)cRelationAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Keyword cAKeyword_2_0 = (Keyword)cAlternatives_2.eContents().get(0);
		private final Keyword cAnKeyword_2_1 = (Keyword)cAlternatives_2.eContents().get(1);
		private final Assignment cConceptAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cConceptConceptParserRuleCall_3_0 = (RuleCall)cConceptAssignment_3.eContents().get(0);
		
		//ObjectPropertyAssertion:
		//	individual=NAME relation=Relation ('a' | 'an') concept=Concept;
		@Override public ParserRule getRule() { return rule; }
		
		//individual=NAME relation=Relation ('a' | 'an') concept=Concept
		public Group getGroup() { return cGroup; }
		
		//individual=NAME
		public Assignment getIndividualAssignment_0() { return cIndividualAssignment_0; }
		
		//NAME
		public RuleCall getIndividualNAMETerminalRuleCall_0_0() { return cIndividualNAMETerminalRuleCall_0_0; }
		
		//relation=Relation
		public Assignment getRelationAssignment_1() { return cRelationAssignment_1; }
		
		//Relation
		public RuleCall getRelationRelationParserRuleCall_1_0() { return cRelationRelationParserRuleCall_1_0; }
		
		//('a' | 'an')
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//'a'
		public Keyword getAKeyword_2_0() { return cAKeyword_2_0; }
		
		//'an'
		public Keyword getAnKeyword_2_1() { return cAnKeyword_2_1; }
		
		//concept=Concept
		public Assignment getConceptAssignment_3() { return cConceptAssignment_3; }
		
		//Concept
		public RuleCall getConceptConceptParserRuleCall_3_0() { return cConceptConceptParserRuleCall_3_0; }
	}
	public class ConceptElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.Concept");
		private final Assignment cConceptNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cConceptNameNAMETerminalRuleCall_0 = (RuleCall)cConceptNameAssignment.eContents().get(0);
		
		//Concept:
		//	conceptName=NAME;
		@Override public ParserRule getRule() { return rule; }
		
		//conceptName=NAME
		public Assignment getConceptNameAssignment() { return cConceptNameAssignment; }
		
		//NAME
		public RuleCall getConceptNameNAMETerminalRuleCall_0() { return cConceptNameNAMETerminalRuleCall_0; }
	}
	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.Variable");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameVARIABLE_NAMETerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//Variable:
		//	name=VARIABLE_NAME;
		@Override public ParserRule getRule() { return rule; }
		
		//name=VARIABLE_NAME
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//VARIABLE_NAME
		public RuleCall getNameVARIABLE_NAMETerminalRuleCall_0() { return cNameVARIABLE_NAMETerminalRuleCall_0; }
	}
	
	
	private final ModelElements pModel;
	private final SentenceElements pSentence;
	private final NegationRuleTypeElements pNegationRuleType;
	private final AnythingElements pAnything;
	private final NothingElements pNothing;
	private final ConditionalRuleTypeElements pConditionalRuleType;
	private final OnlyCanRuleTypeElements pOnlyCanRuleType;
	private final SubConceptRuleTypeElements pSubConceptRuleType;
	private final MustRuleTypeElements pMustRuleType;
	private final ObjectElements pObject;
	private final CanOnlyRuleTypeElements pCanOnlyRuleType;
	private final CardinalityRuleTypeElements pCardinalityRuleType;
	private final ObjectConceptExpressionElements pObjectConceptExpression;
	private final AndObjectConceptExpressionElements pAndObjectConceptExpression;
	private final OrObjectConceptExpressionElements pOrObjectConceptExpression;
	private final RelationElements pRelation;
	private final DatatypeRelationElements pDatatypeRelation;
	private final ObjectRelationElements pObjectRelation;
	private final ConceptExpressionElements pConceptExpression;
	private final ThatExpressionElements pThatExpression;
	private final StatementListElements pStatementList;
	private final VariableStatementElements pVariableStatement;
	private final DataStatementElements pDataStatement;
	private final FactStatementElements pFactStatement;
	private final ConceptAssertionElements pConceptAssertion;
	private final RoleAssertionElements pRoleAssertion;
	private final DatatypePropertyAssertionElements pDatatypePropertyAssertion;
	private final ObjectPropertyAssertionElements pObjectPropertyAssertion;
	private final TerminalRule tRELATION_NAME;
	private final TerminalRule tNAME;
	private final ConceptElements pConcept;
	private final VariableElements pVariable;
	private final TerminalRule tVARIABLE_NAME;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public ArchcnlGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pModel = new ModelElements();
		this.pSentence = new SentenceElements();
		this.pNegationRuleType = new NegationRuleTypeElements();
		this.pAnything = new AnythingElements();
		this.pNothing = new NothingElements();
		this.pConditionalRuleType = new ConditionalRuleTypeElements();
		this.pOnlyCanRuleType = new OnlyCanRuleTypeElements();
		this.pSubConceptRuleType = new SubConceptRuleTypeElements();
		this.pMustRuleType = new MustRuleTypeElements();
		this.pObject = new ObjectElements();
		this.pCanOnlyRuleType = new CanOnlyRuleTypeElements();
		this.pCardinalityRuleType = new CardinalityRuleTypeElements();
		this.pObjectConceptExpression = new ObjectConceptExpressionElements();
		this.pAndObjectConceptExpression = new AndObjectConceptExpressionElements();
		this.pOrObjectConceptExpression = new OrObjectConceptExpressionElements();
		this.pRelation = new RelationElements();
		this.pDatatypeRelation = new DatatypeRelationElements();
		this.pObjectRelation = new ObjectRelationElements();
		this.pConceptExpression = new ConceptExpressionElements();
		this.pThatExpression = new ThatExpressionElements();
		this.pStatementList = new StatementListElements();
		this.pVariableStatement = new VariableStatementElements();
		this.pDataStatement = new DataStatementElements();
		this.pFactStatement = new FactStatementElements();
		this.pConceptAssertion = new ConceptAssertionElements();
		this.pRoleAssertion = new RoleAssertionElements();
		this.pDatatypePropertyAssertion = new DatatypePropertyAssertionElements();
		this.pObjectPropertyAssertion = new ObjectPropertyAssertionElements();
		this.tRELATION_NAME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.RELATION_NAME");
		this.tNAME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.NAME");
		this.pConcept = new ConceptElements();
		this.pVariable = new VariableElements();
		this.tVARIABLE_NAME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.architecture.cnl.Archcnl.VARIABLE_NAME");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.architecture.cnl.Archcnl".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Model:
	//	sentence+=Sentence*;
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}
	
	//Sentence:
	//	'Every' subject=ConceptExpression ruletype=(MustRuleType | CanOnlyRuleType | CardinalityRuleType |
	//	SubConceptRuleType) | ruletype=(OnlyCanRuleType | ConditionalRuleType | NegationRuleType) | facts+=FactStatement;
	public SentenceElements getSentenceAccess() {
		return pSentence;
	}
	
	public ParserRule getSentenceRule() {
		return getSentenceAccess().getRule();
	}
	
	//NegationRuleType:
	//	Nothing | ('No' subject=ConceptExpression 'can' object=Object) '.';
	public NegationRuleTypeElements getNegationRuleTypeAccess() {
		return pNegationRuleType;
	}
	
	public ParserRule getNegationRuleTypeRule() {
		return getNegationRuleTypeAccess().getRule();
	}
	
	//Anything:
	//	relation=Relation 'anything';
	public AnythingElements getAnythingAccess() {
		return pAnything;
	}
	
	public ParserRule getAnythingRule() {
		return getAnythingAccess().getRule();
	}
	
	//Nothing:
	//	'Nothing' 'can' object=Object '.';
	public NothingElements getNothingAccess() {
		return pNothing;
	}
	
	public ParserRule getNothingRule() {
		return getNothingAccess().getRule();
	}
	
	//ConditionalRuleType:
	//	start='If' subject=ConceptExpression relation=Relation object=ConceptExpression ',' 'then' 'it' 'must'
	//	relation2=Relation 'this' object2=ConceptExpression '.';
	public ConditionalRuleTypeElements getConditionalRuleTypeAccess() {
		return pConditionalRuleType;
	}
	
	public ParserRule getConditionalRuleTypeRule() {
		return getConditionalRuleTypeAccess().getRule();
	}
	
	//OnlyCanRuleType:
	//	start='Only' subject=ConceptExpression 'can' object=Object '.';
	public OnlyCanRuleTypeElements getOnlyCanRuleTypeAccess() {
		return pOnlyCanRuleType;
	}
	
	public ParserRule getOnlyCanRuleTypeRule() {
		return getOnlyCanRuleTypeAccess().getRule();
	}
	
	//SubConceptRuleType:
	//	modifier='must' 'be' object=ConceptExpression '.';
	public SubConceptRuleTypeElements getSubConceptRuleTypeAccess() {
		return pSubConceptRuleType;
	}
	
	public ParserRule getSubConceptRuleTypeRule() {
		return getSubConceptRuleTypeAccess().getRule();
	}
	
	//MustRuleType:
	//	modifier='must' object=Object '.';
	public MustRuleTypeElements getMustRuleTypeAccess() {
		return pMustRuleType;
	}
	
	public ParserRule getMustRuleTypeRule() {
		return getMustRuleTypeAccess().getRule();
	}
	
	//Object:
	//	anything=Anything | expression=ObjectConceptExpression (objectAndList+=AndObjectConceptExpression |
	//	objectOrList+=OrObjectConceptExpression)*;
	public ObjectElements getObjectAccess() {
		return pObject;
	}
	
	public ParserRule getObjectRule() {
		return getObjectAccess().getRule();
	}
	
	//CanOnlyRuleType:
	//	modifier='can-only' object=Object '.';
	public CanOnlyRuleTypeElements getCanOnlyRuleTypeAccess() {
		return pCanOnlyRuleType;
	}
	
	public ParserRule getCanOnlyRuleTypeRule() {
		return getCanOnlyRuleTypeAccess().getRule();
	}
	
	////TODO: must anstatt can. Problem: Konflikt mit MustRuleType
	//CardinalityRuleType:
	//	modifer='can' object=Object '.';
	public CardinalityRuleTypeElements getCardinalityRuleTypeAccess() {
		return pCardinalityRuleType;
	}
	
	public ParserRule getCardinalityRuleTypeRule() {
		return getCardinalityRuleTypeAccess().getRule();
	}
	
	//ObjectConceptExpression:
	//	relation=Relation (cardinality=('at-most' | 'at-least' | 'exactly') number=INT)? concept=ConceptExpression |
	//	relation=DatatypeRelation data=DataStatement;
	public ObjectConceptExpressionElements getObjectConceptExpressionAccess() {
		return pObjectConceptExpression;
	}
	
	public ParserRule getObjectConceptExpressionRule() {
		return getObjectConceptExpressionAccess().getRule();
	}
	
	//AndObjectConceptExpression:
	//	'and' expression=ObjectConceptExpression;
	public AndObjectConceptExpressionElements getAndObjectConceptExpressionAccess() {
		return pAndObjectConceptExpression;
	}
	
	public ParserRule getAndObjectConceptExpressionRule() {
		return getAndObjectConceptExpressionAccess().getRule();
	}
	
	//OrObjectConceptExpression:
	//	'or' expression=ObjectConceptExpression;
	public OrObjectConceptExpressionElements getOrObjectConceptExpressionAccess() {
		return pOrObjectConceptExpression;
	}
	
	public ParserRule getOrObjectConceptExpressionRule() {
		return getOrObjectConceptExpressionAccess().getRule();
	}
	
	//Relation:
	//	ObjectRelation | DatatypeRelation;
	public RelationElements getRelationAccess() {
		return pRelation;
	}
	
	public ParserRule getRelationRule() {
		return getRelationAccess().getRule();
	}
	
	//DatatypeRelation:
	//	relationName=RELATION_NAME 'equal-to';
	public DatatypeRelationElements getDatatypeRelationAccess() {
		return pDatatypeRelation;
	}
	
	public ParserRule getDatatypeRelationRule() {
		return getDatatypeRelationAccess().getRule();
	}
	
	//ObjectRelation:
	//	relationName=RELATION_NAME;
	public ObjectRelationElements getObjectRelationAccess() {
		return pObjectRelation;
	}
	
	public ParserRule getObjectRelationRule() {
		return getObjectRelationAccess().getRule();
	}
	
	//ConceptExpression:
	//	('a' | 'an')? concept=Concept that+=ThatExpression*;
	public ConceptExpressionElements getConceptExpressionAccess() {
		return pConceptExpression;
	}
	
	public ParserRule getConceptExpressionRule() {
		return getConceptExpressionAccess().getRule();
	}
	
	//ThatExpression:
	//	'that' '(' list+=StatementList+ ')';
	public ThatExpressionElements getThatExpressionAccess() {
		return pThatExpression;
	}
	
	public ParserRule getThatExpressionRule() {
		return getThatExpressionAccess().getRule();
	}
	
	//StatementList:
	//	'and'? (relation=Relation (expression=ConceptExpression | expression=DataStatement | expression=VariableStatement));
	public StatementListElements getStatementListAccess() {
		return pStatementList;
	}
	
	public ParserRule getStatementListRule() {
		return getStatementListAccess().getRule();
	}
	
	//VariableStatement:
	//	concept=Concept variable=Variable;
	public VariableStatementElements getVariableStatementAccess() {
		return pVariableStatement;
	}
	
	public ParserRule getVariableStatementRule() {
		return getVariableStatementAccess().getRule();
	}
	
	//DataStatement:
	//	stringValue=STRING | intValue=INT;
	public DataStatementElements getDataStatementAccess() {
		return pDataStatement;
	}
	
	public ParserRule getDataStatementRule() {
		return getDataStatementAccess().getRule();
	}
	
	//FactStatement:
	//	(assertion=ConceptAssertion | assertion=RoleAssertion) '.';
	public FactStatementElements getFactStatementAccess() {
		return pFactStatement;
	}
	
	public ParserRule getFactStatementRule() {
		return getFactStatementAccess().getRule();
	}
	
	//ConceptAssertion:
	//	individual=NAME 'is' ('a' | 'an') concept=Concept '.';
	public ConceptAssertionElements getConceptAssertionAccess() {
		return pConceptAssertion;
	}
	
	public ParserRule getConceptAssertionRule() {
		return getConceptAssertionAccess().getRule();
	}
	
	//RoleAssertion:
	//	ObjectPropertyAssertion | DatatypePropertyAssertion '.';
	public RoleAssertionElements getRoleAssertionAccess() {
		return pRoleAssertion;
	}
	
	public ParserRule getRoleAssertionRule() {
		return getRoleAssertionAccess().getRule();
	}
	
	//DatatypePropertyAssertion:
	//	individual=NAME relation=DatatypeRelation (string=STRING | int=INT);
	public DatatypePropertyAssertionElements getDatatypePropertyAssertionAccess() {
		return pDatatypePropertyAssertion;
	}
	
	public ParserRule getDatatypePropertyAssertionRule() {
		return getDatatypePropertyAssertionAccess().getRule();
	}
	
	//ObjectPropertyAssertion:
	//	individual=NAME relation=Relation ('a' | 'an') concept=Concept;
	public ObjectPropertyAssertionElements getObjectPropertyAssertionAccess() {
		return pObjectPropertyAssertion;
	}
	
	public ParserRule getObjectPropertyAssertionRule() {
		return getObjectPropertyAssertionAccess().getRule();
	}
	
	//terminal RELATION_NAME:
	//	'a'..'z' ('A'..'Z' | 'a'..'z')+;
	public TerminalRule getRELATION_NAMERule() {
		return tRELATION_NAME;
	}
	
	//terminal NAME:
	//	'A'..'Z' ('A'..'Z' | 'a'..'z')+;
	public TerminalRule getNAMERule() {
		return tNAME;
	}
	
	//Concept:
	//	conceptName=NAME;
	public ConceptElements getConceptAccess() {
		return pConcept;
	}
	
	public ParserRule getConceptRule() {
		return getConceptAccess().getRule();
	}
	
	//Variable:
	//	name=VARIABLE_NAME;
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}
	
	//terminal VARIABLE_NAME:
	//	'A'..'Z';
	public TerminalRule getVARIABLE_NAMERule() {
		return tVARIABLE_NAME;
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
